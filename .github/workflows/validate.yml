name: Validate HTML

on:
  push:
    paths:
      - '**.html'

jobs:
  validate:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install HTML validator
        run: |
          echo "Installation de html-validate..."
          npm install -g html-validate || {
            echo "√âchec de l'installation de html-validate, installation d'une alternative..."
            npm install -g htmlhint
          }

      - name: Run HTML validation
        run: |
          echo "# Feedback Automatis√©" > feedback.md
          echo "" >> feedback.md
          echo "## R√©sultats de la validation HTML :" >> feedback.md
          echo "" >> feedback.md
          
          # Chercher tous les fichiers HTML
          html_files=$(find . -name "*.html" -not -path "./.git/*")

          # Initialiser le score de validation global
          validation_score=3  # Score par d√©faut maximum

          if [ -z "$html_files" ]; then
            echo "‚ùå Aucun fichier HTML trouv√© dans le repository." >> feedback.md
            validation_score=0
          else
            echo "üìÅ **Fichiers HTML analys√©s** :" >> feedback.md
            for file in $html_files; do
              echo "- $file" >> feedback.md
            done
            echo "" >> feedback.md
            
            # Debug: v√©rifier que html-validate est install√©
            echo "Debug: V√©rification de html-validate..."
            if command -v html-validate >/dev/null 2>&1; then
              echo "Debug: html-validate trouv√©, utilisation..."
              for file in $html_files; do
                echo "Debug: Analyse de $file avec html-validate..."
                if html-validate "$file" > "validation_${file##*/}.tmp" 2>&1; then
                  if [ -s "validation_${file##*/}.tmp" ]; then
                    echo "‚ö†Ô∏è **Erreurs dans $file** :" >> feedback.md
                    echo '```' >> feedback.md
                    cat "validation_${file##*/}.tmp" >> feedback.md
                    echo '```' >> feedback.md
                    # Compter les erreurs dans ce fichier
                    file_errors=$(grep -c "error\|Error\|ERROR" "validation_${file##*/}.tmp" 2>/dev/null || echo "1")
                    total_errors=$((total_errors + file_errors))
                  fi
                else
                  echo "‚ö†Ô∏è **Erreurs dans $file** :" >> feedback.md
                  echo '```' >> feedback.md
                  cat "validation_${file##*/}.tmp" >> feedback.md
                  echo '```' >> feedback.md
                  file_errors=$(grep -c "error\|Error\|ERROR" "validation_${file##*/}.tmp" 2>/dev/null || echo "1")
                  total_errors=$((total_errors + file_errors))
                fi
                rm -f "validation_${file##*/}.tmp"
              done
            elif command -v htmlhint >/dev/null 2>&1; then
              echo "Debug: html-validate non trouv√©, utilisation de htmlhint..."
              for file in $html_files; do
                echo "Debug: Analyse de $file avec htmlhint..."
                if ! htmlhint "$file" > "validation_${file##*/}.tmp" 2>&1; then
                  echo "‚ö†Ô∏è **Erreurs dans $file** :" >> feedback.md
                  echo '```' >> feedback.md
                  cat "validation_${file##*/}.tmp" >> feedback.md
                  echo '```' >> feedback.md
                  file_errors=$(grep -c "error\|Error\|ERROR" "validation_${file##*/}.tmp" 2>/dev/null || echo "1")
                  total_errors=$((total_errors + file_errors))
                fi
                rm -f "validation_${file##*/}.tmp"
              done
            else
              echo "‚ö†Ô∏è **Validation basique** : Aucun validateur HTML install√©" >> feedback.md
              total_errors=0
            fi
            
            # V√©rifications manuelles suppl√©mentaires
            for file in $html_files; do
              # V√©rifier images sans alt
              if grep -q '<img' "$file" && ! grep -q '<img[^>]*alt=' "$file"; then
                total_errors=$((total_errors + 1))
              fi
              
              # V√©rifier balises non ferm√©es
              if grep -q '<p>' "$file"; then
                p_open=$(grep -c '<p>' "$file" 2>/dev/null || echo "0")
                p_close=$(grep -c '</p>' "$file" 2>/dev/null || echo "0")
                if [ "$p_open" -gt "$p_close" ]; then
                  total_errors=$((total_errors + 1))
                fi
              fi
            done
            
            # Calculer le score final de validation
            if [ "$total_errors" -eq 0 ]; then
              validation_score=3
              echo "‚úÖ **Aucune erreur de validation HTML d√©tect√©e !**" >> feedback.md
              echo "Votre code HTML semble correct." >> feedback.md
            elif [ "$total_errors" -le 2 ]; then
              validation_score=2
              echo "‚ö†Ô∏è **Quelques erreurs de validation d√©tect√©es** (Score: 2/3)" >> feedback.md
              echo "Votre code contient $total_errors erreur(s)." >> feedback.md
            else
              validation_score=1
              echo "‚ùå **Plusieurs erreurs de validation d√©tect√©es** (Score: 1/3)" >> feedback.md
              echo "Votre code contient $total_errors erreur(s)." >> feedback.md
            fi
            
            # Sauvegarder le score dans un fichier pour les √©tapes suivantes
            echo "$validation_score" > validation_score.tmp
          fi
          echo "" >> feedback.md

      - name: Analyze validation errors and provide solutions
        run: |
          echo "## üîß Solutions aux erreurs de validation d√©tect√©es :" >> feedback.md
          echo "" >> feedback.md
          
          html_files=$(find . -name "*.html" -not -path "./.git/*")
          solutions_provided=false
          
          for file in $html_files; do
            # Analyser le contenu pour d√©tecter des probl√®mes sp√©cifiques
            
            # 1. Images sans alt
            if grep -q '<img[^>]*>' "$file" && ! grep -q '<img[^>]*alt=' "$file"; then
              echo "### ‚ôø **Erreur d'accessibilit√© : Images sans attribut alt**" >> feedback.md
              echo "" >> feedback.md
              echo "**Probl√®me d√©tect√© :** \`<img>\` sans attribut \`alt\`" >> feedback.md
              echo "" >> feedback.md
              echo "**Solution :**" >> feedback.md
              echo '```html' >> feedback.md
              echo "<!-- ‚ùå Erreur actuelle -->" >> feedback.md
              grep -o '<img[^>]*>' "$file" | head -1 >> feedback.md
              echo "" >> feedback.md
              echo "<!-- ‚úÖ Correction -->" >> feedback.md
              img_line=$(grep -o '<img[^>]*>' "$file" | head -1)
              corrected_img=$(echo "$img_line" | sed 's/>/ alt="Description de l'\''image">/')
              echo "$corrected_img" >> feedback.md
              echo '```' >> feedback.md
              echo "" >> feedback.md
              solutions_provided=true
            fi
            
            # 2. Balises non ferm√©es
            if grep -q '<p>' "$file"; then
              # V√©rifier s'il y a des <p> potentiellement non ferm√©s
              p_open=$(grep -c '<p>' "$file" 2>/dev/null || echo "0")
              p_close=$(grep -c '</p>' "$file" 2>/dev/null || echo "0")
              if [ "$p_open" -gt "$p_close" ]; then
                echo "### üîó **Erreur de structure : Balise \`<p>\` non ferm√©e**" >> feedback.md
                echo "" >> feedback.md
                echo "**Probl√®me d√©tect√© :** Balise \`<p>\` ouverte mais pas ferm√©e correctement" >> feedback.md
                echo "" >> feedback.md
                echo "**Solution :** Ajouter la balise de fermeture \`</p>\`" >> feedback.md
                echo '```html' >> feedback.md
                echo "<!-- ‚ùå Erreur -->" >> feedback.md
                echo "<p>" >> feedback.md
                echo "  Votre texte..." >> feedback.md
                echo "<!-- Pas de fermeture -->" >> feedback.md
                echo "" >> feedback.md
                echo "<!-- ‚úÖ Correction -->" >> feedback.md
                echo "<p>" >> feedback.md
                echo "  Votre texte..." >> feedback.md
                echo "</p>" >> feedback.md
                echo '```' >> feedback.md
                echo "" >> feedback.md
                solutions_provided=true
              fi
            fi
            
            # 3. Balises li non ferm√©es
            if grep -q '<li>' "$file"; then
              li_open=$(grep -c '<li>' "$file" 2>/dev/null || echo "0")
              li_close=$(grep -c '</li>' "$file" 2>/dev/null || echo "0")
              if [ "$li_open" -gt "$li_close" ]; then
                echo "### üìù **Erreur de liste : Balise \`<li>\` non ferm√©e**" >> feedback.md
                echo "" >> feedback.md
                echo "**Probl√®me d√©tect√© :** √âl√©ment de liste sans balise de fermeture" >> feedback.md
                echo "" >> feedback.md
                echo "**Solution :** Ajouter \`</li>\` √† chaque √©l√©ment" >> feedback.md
                echo '```html' >> feedback.md
                echo "<!-- ‚ùå Erreur -->" >> feedback.md
                echo "<ul>" >> feedback.md
                echo "  <li>Premier √©l√©ment" >> feedback.md
                echo "  <li>Deuxi√®me √©l√©ment</li>" >> feedback.md
                echo "</ul>" >> feedback.md
                echo "" >> feedback.md
                echo "<!-- ‚úÖ Correction -->" >> feedback.md
                echo "<ul>" >> feedback.md
                echo "  <li>Premier √©l√©ment</li>" >> feedback.md
                echo "  <li>Deuxi√®me √©l√©ment</li>" >> feedback.md
                echo "</ul>" >> feedback.md
                echo '```' >> feedback.md
                echo "" >> feedback.md
                solutions_provided=true
              fi
            fi
            
            # 4. Balises blockquote non ferm√©es
            if grep -q '<blockquote>' "$file"; then
              bq_open=$(grep -c '<blockquote>' "$file" 2>/dev/null || echo "0")
              bq_close=$(grep -c '</blockquote>' "$file" 2>/dev/null || echo "0")
              if [ "$bq_open" -gt "$bq_close" ]; then
                echo "### üí¨ **Erreur de citation : Balise \`<blockquote>\` non ferm√©e**" >> feedback.md
                echo "" >> feedback.md
                echo "**Probl√®me d√©tect√© :** Citation ouverte mais pas ferm√©e" >> feedback.md
                echo "" >> feedback.md
                echo "**Solution :** Ajouter \`</blockquote>\` avant la fermeture du conteneur" >> feedback.md
                echo '```html' >> feedback.md
                echo "<!-- ‚ùå Erreur -->" >> feedback.md
                echo "<footer>" >> feedback.md
                echo "  <blockquote>" >> feedback.md
                echo "    \"Votre citation...\"" >> feedback.md
                echo "  <!-- Manque </blockquote> -->" >> feedback.md
                echo "</footer>" >> feedback.md
                echo "" >> feedback.md
                echo "<!-- ‚úÖ Correction -->" >> feedback.md
                echo "<footer>" >> feedback.md
                echo "  <blockquote>" >> feedback.md
                echo "    \"Votre citation...\"" >> feedback.md
                echo "  </blockquote>" >> feedback.md
                echo "</footer>" >> feedback.md
                echo '```' >> feedback.md
                echo "" >> feedback.md
                solutions_provided=true
              fi
            fi
            
            # 5. Espaces en fin de ligne
            if grep -q '[[:space:]]$' "$file"; then
              echo "### üßπ **Probl√®me de formatage : Espaces en fin de ligne**" >> feedback.md
              echo "" >> feedback.md
              echo "**Probl√®me d√©tect√© :** Espaces inutiles √† la fin des lignes" >> feedback.md
              echo "" >> feedback.md
              echo "**Solution :** Supprimer les espaces en fin de ligne" >> feedback.md
              echo "- Dans VS Code : Rechercher avec regex \`[[:space:]]+$\` et remplacer par rien" >> feedback.md
              echo "- Ou configurer VS Code pour supprimer automatiquement les espaces" >> feedback.md
              echo "" >> feedback.md
              solutions_provided=true
            fi
          done
          
          if [ "$solutions_provided" = false ]; then
            echo "‚úÖ **Aucune erreur de validation sp√©cifique d√©tect√©e !**" >> feedback.md
            echo "Votre code HTML semble bien structur√©." >> feedback.md
          fi
          echo "" >> feedback.md

      - name: Analyze HTML code quality
        run: |
          echo "## Analyse de la qualit√© du code :" >> feedback.md
          echo "" >> feedback.md
          
          html_files=$(find . -name "*.html" -not -path "./.git/*")
          
          for file in $html_files; do
            echo "### üìÑ Analyse de \`$file\` :" >> feedback.md
            echo "" >> feedback.md
            
            # Points forts
            echo "#### ‚úÖ **Points forts d√©tect√©s** :" >> feedback.md
            
            # V√©rifier DOCTYPE
            if grep -q "<!DOCTYPE html>" "$file"; then
              echo "- ‚úÖ D√©claration DOCTYPE HTML5 pr√©sente" >> feedback.md
            fi
            
            # V√©rifier lang
            if grep -q '<html.*lang=' "$file"; then
              echo "- ‚úÖ Attribut lang d√©fini pour l'accessibilit√©" >> feedback.md
            fi
            
            # V√©rifier charset
            if grep -q 'charset=' "$file"; then
              echo "- ‚úÖ Encodage de caract√®res sp√©cifi√©" >> feedback.md
            fi
            
            # V√©rifier viewport
            if grep -q 'viewport' "$file"; then
              echo "- ‚úÖ Meta viewport pr√©sent (responsive design)" >> feedback.md
            fi
            
            # V√©rifier balises s√©mantiques
            semantic_tags=("header" "main" "footer" "nav" "section" "article" "aside")
            for tag in "${semantic_tags[@]}"; do
              if grep -q "<$tag" "$file"; then
                echo "- ‚úÖ Utilisation de balises s√©mantiques (\`<$tag>\`)" >> feedback.md
              fi
            done
            
            # V√©rifier structure de base
            if grep -q "<title>" "$file"; then
              echo "- ‚úÖ Titre de page d√©fini" >> feedback.md
            fi
            
            echo "" >> feedback.md
            
            # Points √† am√©liorer
            echo "#### ‚ö†Ô∏è **Points √† am√©liorer** :" >> feedback.md
            
            issues_found=false
            
            # V√©rifier images sans alt
            if grep -q '<img' "$file" && ! grep -q '<img[^>]*alt=' "$file"; then
              echo "- ‚ö†Ô∏è Images sans attribut alt d√©tect√©es" >> feedback.md
              issues_found=true
            fi
            
            # V√©rifier balises obsol√®tes
            obsolete_tags=("font" "center" "b" "i" "u")
            for tag in "${obsolete_tags[@]}"; do
              if grep -q "<$tag" "$file"; then
                echo "- ‚ö†Ô∏è Balise obsol√®te d√©tect√©e : \`<$tag>\` (utiliser CSS √† la place)" >> feedback.md
                issues_found=true
              fi
            done
            
            # V√©rifier styles inline
            if grep -q 'style=' "$file"; then
              echo "- ‚ö†Ô∏è Styles inline d√©tect√©s (consid√©rer l'externalisation CSS)" >> feedback.md
              issues_found=true
            fi
            
            # V√©rifier liens sans title ou texte descriptif
            if grep -q '<a.*href.*>' "$file"; then
              if ! grep -q '<a.*title=' "$file"; then
                echo "- ‚ÑπÔ∏è Consid√©rer l'ajout d'attributs title aux liens pour l'accessibilit√©" >> feedback.md
                issues_found=true
              fi
            fi
            
            if [ "$issues_found" = false ]; then
              echo "- ‚úÖ Aucun probl√®me majeur d√©tect√© dans ce fichier !" >> feedback.md
            fi
            
            echo "" >> feedback.md
          done

      - name: Check for alt attributes in images
        run: |
          echo "## V√©rification d√©taill√©e des images :" >> feedback.md
          echo "" >> feedback.md
          
          # Chercher les images dans les fichiers HTML
          html_files=$(find . -name "*.html" -not -path "./.git/*")
          images_found=false
          
          for file in $html_files; do
            if grep -q '<img' "$file" 2>/dev/null; then
              images_found=true
              echo "üñºÔ∏è **Images dans $file** :" >> feedback.md
              
              # Extraire toutes les balises img et les traiter
              grep -o '<img[^>]*>' "$file" > img_temp.txt
              while IFS= read -r img_tag; do
                if echo "$img_tag" | grep -q 'alt='; then
                  echo "  ‚úÖ Image avec attribut alt : \`$img_tag\`" >> feedback.md
                else
                  echo "  ‚ùå **Image sans attribut alt** : \`$img_tag\`" >> feedback.md
                  echo "    üí° **Suggestion** : Ajouter \`alt=\"Description de l'image\"\`" >> feedback.md
                fi
              done < img_temp.txt
              rm -f img_temp.txt
              echo "" >> feedback.md
            fi
          done
          
          if [ "$images_found" = false ]; then
            echo "‚ÑπÔ∏è Aucune image trouv√©e dans les fichiers HTML." >> feedback.md
          fi
          echo "" >> feedback.md

      - name: Generate personalized recommendations  
        run: |
          echo "## üí° Recommandations personnalis√©es :" >> feedback.md
          echo "" >> feedback.md
          echo "### Actions prioritaires :" >> feedback.md
          
          html_files=$(find . -name "*.html" -not -path "./.git/*")
          priority_actions=false
          
          for file in $html_files; do
            if grep -q '<img' "$file" && ! grep -q 'alt=' "$file"; then
              echo "- ‚ôø **Urgent** : Ajouter des attributs \`alt\` aux images dans \`$file\`" >> feedback.md
              priority_actions=true
            fi
            
            if ! grep -q 'viewport' "$file"; then
              echo "- üì± **Recommand√©** : Ajouter la meta viewport dans \`$file\` pour le responsive" >> feedback.md
              priority_actions=true
            fi
          done
          
          if [ "$priority_actions" = false ]; then
            echo "‚úÖ Aucune action prioritaire n√©cessaire !" >> feedback.md
          fi
          echo "" >> feedback.md

      - name: Pedagogical evaluation and grading
        run: |
          # Attendre un peu pour √©viter les conflits de fichier
          sleep 1
          
          # Cr√©er une nouvelle section d'√©valuation
          {
            echo ""
            echo "---"
            echo ""
            echo "# üéì √âvaluation P√©dagogique - Exercice Norman Borlaug"
            echo ""
            echo "## üìã Analyse du travail rendu :"
            echo ""
          } >> feedback.md
          
          html_files=$(find . -name "*.html" -not -path "./.git/*")
          
          for file in $html_files; do
            {
              echo "### üìÑ √âvaluation de \`$file\` :"
              echo ""
              
              # Compter les lignes de code
              line_count=$(wc -l < "$file")
              echo "üìè **Nombre de lignes de code :** $line_count lignes"
              echo ""
              
              # V√©rifier les contraintes de longueur
              if [ "$line_count" -lt 30 ]; then
                echo "‚ö†Ô∏è **Attention :** Travail incomplet (moins de 30 lignes). Note limit√©e √† 6/12 maximum."
                max_score=6
              elif [ "$line_count" -gt 80 ]; then
                echo "‚ÑπÔ∏è **Information :** Code tr√®s long (plus de 80 lignes). V√©rifiez la concision."
                max_score=12
              else
                echo "‚úÖ **Longueur appropri√©e :** Respect des contraintes (30-80 lignes)."
                max_score=12
              fi
              echo ""
            } >> feedback.md
            
            # CRIT√àRE 1: Structure HTML
            structure_score=0
            {
              echo "### üèóÔ∏è **Crit√®re 1 : Structure HTML** (/3 points)"
              echo ""
            } >> feedback.md
            
            if grep -q "<header>" "$file"; then
              echo "‚úÖ Balise \`<header>\` pr√©sente (+1 point)" >> feedback.md
              structure_score=$((structure_score + 1))
            else
              echo "‚ùå Balise \`<header>\` manquante (0 point)" >> feedback.md
            fi
            
            if grep -q "<main>" "$file"; then
              echo "‚úÖ Balise \`<main>\` pr√©sente (+1 point)" >> feedback.md
              structure_score=$((structure_score + 1))
            else
              echo "‚ùå Balise \`<main>\` manquante (0 point)" >> feedback.md
            fi
            
            if grep -q "<footer>" "$file"; then
              echo "‚úÖ Balise \`<footer>\` pr√©sente (+1 point)" >> feedback.md
              structure_score=$((structure_score + 1))
            else
              echo "‚ùå Balise \`<footer>\` manquante (0 point)" >> feedback.md
            fi
            
            {
              echo "**Score Structure HTML : $structure_score/3**"
              echo ""
            } >> feedback.md
            
            # CRIT√àRE 2: √âl√©ments requis
            elements_score=0
            {
              echo "### üéØ **Crit√®re 2 : √âl√©ments requis de l'exercice** (/3 points)"
              echo ""
            } >> feedback.md
            
            # V√©rifier figure + figcaption
            if grep -q "<figure>" "$file" && grep -q "<figcaption>" "$file"; then
              echo "‚úÖ Image avec l√©gende (\`<figure>\` + \`<figcaption>\`) (+1 point)" >> feedback.md
              elements_score=$((elements_score + 1))
            else
              echo "‚ùå Image avec l√©gende manquante (\`<figure>\` + \`<figcaption>\`) (0 point)" >> feedback.md
            fi
            
            # V√©rifier liste
            if grep -q "<ul>" "$file" || grep -q "<ol>" "$file"; then
              echo "‚úÖ Liste d'accomplissements pr√©sente (\`<ul>\` ou \`<ol>\`) (+1 point)" >> feedback.md
              elements_score=$((elements_score + 1))
            else
              echo "‚ùå Liste d'accomplissements manquante (0 point)" >> feedback.md
            fi
            
            # V√©rifier blockquote + lien
            if grep -q "<blockquote>" "$file" && grep -q "<a.*href.*>" "$file"; then
              echo "‚úÖ Citation (\`<blockquote>\`) et lien externe pr√©sents (+1 point)" >> feedback.md
              elements_score=$((elements_score + 1))
            else
              echo "‚ùå Citation ou lien externe manquant (0 point)" >> feedback.md
            fi
            
            {
              echo "**Score √âl√©ments requis : $elements_score/3**"
              echo ""
            } >> feedback.md
            
            # CRIT√àRE 3: Balises s√©mantiques
            semantic_score=0
            semantic_count=0
            {
              echo "### üè∑Ô∏è **Crit√®re 3 : Balises s√©mantiques** (/3 points)"
              echo ""
            } >> feedback.md
            
           if grep -q "<section>" "$file" && grep -q "<h[2-6]>" "$file"; then
              # V√©rifier si les titres sont bien dans des sections
              sections_with_titles=$(grep -c "<section>" "$file" 2>/dev/null || echo "0")
              if [ "$sections_with_titles" -gt 0 ]; then
                echo "‚úÖ Excellente utilisation de \`<section>\` avec titres hi√©rarchiques" >> feedback.md
                semantic_count=$((semantic_count + 3))
              fi
            fi

            # V√©rifier mauvaise utilisation de div avec titres
            if grep -q "<div>" "$file" && grep -q "<h[2-6]>" "$file"; then
              # V√©rifier si des titres sont dans des divs au lieu de sections
              echo "‚ùå Mauvaise utilisation de \`<div>\` avec titres - utiliser \`<section>\` √† la place" >> feedback.md
              semantic_count=$((semantic_count - 2))
            fi


            if grep -q "<article>" "$file"; then
              echo "‚úÖ Utilisation de \`<article>\`" >> feedback.md
              semantic_count=$((semantic_count + 1))
            fi
            if grep -q "<nav>" "$file"; then
              echo "‚úÖ Utilisation de \`<nav>\`" >> feedback.md
              semantic_count=$((semantic_count + 1))
            fi
            if grep -q "<aside>" "$file"; then
              echo "‚úÖ Utilisation de \`<aside>\`" >> feedback.md
              semantic_count=$((semantic_count + 1))
            fi
            
            # Attribution des points
            if [ "$semantic_count" -ge 3 ]; then
              semantic_score=3
              echo "**Excellent usage des balises s√©mantiques (+3 points)**" >> feedback.md
            elif [ "$semantic_count" -eq 2 ]; then
              semantic_score=2
              echo "**Bon usage des balises s√©mantiques (+2 points)**" >> feedback.md
            elif [ "$semantic_count" -eq 1 ]; then
              semantic_score=1
              echo "**Usage basique des balises s√©mantiques (+1 point)**" >> feedback.md
            else
              semantic_score=0
              echo "‚ùå **Aucune balise s√©mantique avanc√©e d√©tect√©e (0 point)**" >> feedback.md
            fi
            
            {
              echo "**Score Balises s√©mantiques : $semantic_score/3**"
              echo ""
            } >> feedback.md
            
            # CRIT√àRE 4: Validation HTML
            validation_score=2  # Score par d√©faut
            {
              echo "### ‚úÖ **Crit√®re 4 : Validation HTML** (/3 points)"
              echo ""
              echo "‚ÑπÔ∏è **Validation basique effectu√©e (+2 points)**"
              echo "**Score Validation HTML : $validation_score/3**"
              echo ""
            } >> feedback.md
            
            # CALCUL FINAL
            total_score=$((structure_score + elements_score + semantic_score + validation_score))
            if [ "$total_score" -gt "$max_score" ]; then
              total_score=$max_score
            fi
            
            # R√âSUM√â
            {
              echo "## üîé **R√©sum√© des points obtenus :**"
              echo ""
              echo "| Crit√®re | Points obtenus | Points max |"
              echo "|---------|----------------|------------|"
              echo "| Structure HTML | $structure_score | 3 |"
              echo "| √âl√©ments requis | $elements_score | 3 |"
              echo "| Balises s√©mantiques | $semantic_score | 3 |"
              echo "| Validation HTML | $validation_score | 3 |"
              echo "| **TOTAL** | **$total_score** | **12** |"
              echo ""
            } >> feedback.md
            
            # STATUT
            line_count=$(wc -l < "$file")
            if [ "$line_count" -lt 30 ]; then
              {
                echo "## üìã **Statut du travail :** ‚ùå NON VALID√â"
                echo "**Raison :** Travail incomplet (moins de 30 lignes requises)"
              } >> feedback.md
            elif [ "$total_score" -ge 8 ]; then
              {
                echo "## üìã **Statut du travail :** ‚úÖ VALID√â"
                echo "**F√©licitations !** Votre travail respecte les consignes de l'exercice."
              } >> feedback.md
            else
              {
                echo "## ÔøΩ **Statut du travail :** ‚ö†Ô∏è √Ä AM√âLIORER"
                echo "**Note insuffisante.** Veuillez corriger les points mentionn√©s ci-dessus."
              } >> feedback.md
            fi
            
            echo "" >> feedback.md
          done

      - name: Add pedagogical feedback with code examples
        run: |
          cat >> feedback.md << 'EOF'
          ## üìö Guide de r√©solution des erreurs courantes :
          
          ### üéØ **Erreurs fr√©quentes et leurs solutions** :
          
          #### 1. Erreur `wcag/h37` - Images sans attribut alt
          **Cause :** L'attribut `alt` est obligatoire pour l'accessibilit√©
          ```html
          <!-- ‚ùå Probl√®me -->
          <img src="image.jpg">
          
          <!-- ‚úÖ Solution -->
          <img src="image.jpg" alt="Nelson Mandela souriant en 2008">
          ```
          
          #### 2. Erreur `no-implicit-close` - Balises non ferm√©es
          **Cause :** HTML5 ferme automatiquement certaines balises, mais c'est une mauvaise pratique
          ```html
          <!-- ‚ùå Probl√®me -->
          <p>Texte
          <h2>Titre</h2>
          
          <!-- ‚úÖ Solution -->
          <p>Texte</p>
          <h2>Titre</h2>
          ```
          
          #### 3. Erreur `close-order` - Ordre de fermeture incorrect
          **Cause :** Les balises doivent √™tre ferm√©es dans l'ordre inverse d'ouverture
          ```html
          <!-- ‚ùå Probl√®me -->
          <footer>
            <blockquote>
              Citation...
          </footer> <!-- blockquote jamais ferm√© -->
          
          <!-- ‚úÖ Solution -->
          <footer>
            <blockquote>
              Citation...
            </blockquote>
          </footer>
          ```
          
          #### 4. Erreur `no-trailing-whitespace` - Espaces en fin de ligne
          **Cause :** Espaces inutiles √† la fin des lignes
          **Solution :** Configurez votre √©diteur pour supprimer automatiquement ces espaces
          
          ### üí° **Conseils pour √©viter ces erreurs** :
          
          - **Utilisez un √©diteur avec coloration syntaxique** (VS Code, Sublime Text, etc.)
          - **Activez l'auto-completion HTML** pour les balises de fermeture
          - **Installez des extensions** comme "Auto Close Tag" dans VS Code
          - **Utilisez l'indentation** pour visualiser la structure
          - **Validez r√©guli√®rement** votre code pendant le d√©veloppement
          
          ### üîß **Configuration VS Code recommand√©e** :
          ```json
          {
            "files.trimTrailingWhitespace": true,
            "editor.formatOnSave": true,
            "html.autoClosingTags": true
          }
          ```
          
          EOF

      - name: Commit feedback
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add feedback.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Add automated feedback"
            git push
          fi
